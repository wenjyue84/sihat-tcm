name: Sihat TCM CI/CD Pipeline

on:
  push:
    branches: [ main, develop, staging ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      rollback_sha:
        description: 'Commit SHA to rollback to (leave empty for normal deployment)'
        required: false
        type: string
      skip_tests:
        description: 'Skip tests (emergency deployments only)'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '18'
  PNPM_VERSION: '8'
  DEPLOYMENT_TIMEOUT: '600'  # 10 minutes
  HEALTH_CHECK_RETRIES: '10'

jobs:
  # Pre-deployment validation
  pre-deployment:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request'
    
    outputs:
      should_deploy: ${{ steps.deployment_check.outputs.should_deploy }}
      target_environment: ${{ steps.deployment_check.outputs.target_environment }}
      is_rollback: ${{ steps.deployment_check.outputs.is_rollback }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for rollback validation
        
    - name: Determine deployment strategy
      id: deployment_check
      run: |
        # Determine if this is a rollback
        if [ -n "${{ github.event.inputs.rollback_sha }}" ]; then
          echo "is_rollback=true" >> $GITHUB_OUTPUT
          echo "should_deploy=true" >> $GITHUB_OUTPUT
          
          # Validate rollback commit exists
          if ! git rev-parse --verify "${{ github.event.inputs.rollback_sha }}" >/dev/null 2>&1; then
            echo "âŒ Rollback commit ${{ github.event.inputs.rollback_sha }} does not exist"
            exit 1
          fi
          
          echo "âœ… Rollback validation passed"
        else
          echo "is_rollback=false" >> $GITHUB_OUTPUT
          echo "should_deploy=true" >> $GITHUB_OUTPUT
        fi
        
        # Determine target environment
        if [ "${{ github.event.inputs.environment }}" != "" ]; then
          echo "target_environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
        elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
          echo "target_environment=production" >> $GITHUB_OUTPUT
        elif [ "${{ github.ref }}" = "refs/heads/develop" ] || [ "${{ github.ref }}" = "refs/heads/staging" ]; then
          echo "target_environment=staging" >> $GITHUB_OUTPUT
        else
          echo "target_environment=none" >> $GITHUB_OUTPUT
          echo "should_deploy=false" >> $GITHUB_OUTPUT
        fi
        
    - name: Check deployment window (Production only)
      if: steps.deployment_check.outputs.target_environment == 'production' && steps.deployment_check.outputs.is_rollback == 'false'
      run: |
        # Check if deployment is within allowed window (e.g., business hours)
        current_hour=$(date -u +%H)
        current_day=$(date -u +%u)  # 1=Monday, 7=Sunday
        
        # Allow deployments Monday-Friday, 9 AM - 5 PM UTC (adjust as needed)
        if [ $current_day -ge 1 ] && [ $current_day -le 5 ] && [ $current_hour -ge 9 ] && [ $current_hour -le 17 ]; then
          echo "âœ… Deployment within allowed window"
        elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "âš ï¸ Manual deployment outside business hours - proceeding"
        else
          echo "âŒ Automatic production deployments only allowed during business hours (Mon-Fri, 9 AM - 5 PM UTC)"
          echo "Use manual workflow dispatch for emergency deployments"
          exit 1
        fi

  # Code Quality and Testing
  quality-check:
    name: Code Quality & Testing
    runs-on: ubuntu-latest
    needs: pre-deployment
    if: needs.pre-deployment.outputs.should_deploy == 'true' && (github.event.inputs.skip_tests != 'true' || needs.pre-deployment.outputs.is_rollback == 'true')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.inputs.rollback_sha || github.sha }}
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        
    - name: Setup pnpm
      uses: pnpm/action-setup@v2
      with:
        version: ${{ env.PNPM_VERSION }}
        
    - name: Get pnpm store directory
      shell: bash
      run: |
        echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
        
    - name: Setup pnpm cache
      uses: actions/cache@v3
      with:
        path: ${{ env.STORE_PATH }}
        key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          ${{ runner.os }}-pnpm-store-
          
    - name: Install dependencies
      working-directory: ./sihat-tcm
      run: pnpm install --frozen-lockfile
      
    - name: Type checking
      working-directory: ./sihat-tcm
      run: pnpm run type-check
      
    - name: Linting
      working-directory: ./sihat-tcm
      run: pnpm run lint
      
    - name: Unit tests
      working-directory: ./sihat-tcm
      run: pnpm run test:run
      
    - name: Property-based tests
      working-directory: ./sihat-tcm
      run: pnpm run test:pbt
      
    - name: Build application
      working-directory: ./sihat-tcm
      run: pnpm run build
      env:
        NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
        NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        
    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: build-artifacts-${{ github.sha }}
        path: |
          sihat-tcm/.next/
          sihat-tcm/out/
        retention-days: 7

  # Security Scanning
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: [pre-deployment, quality-check]
    if: needs.pre-deployment.outputs.should_deploy == 'true' && needs.pre-deployment.outputs.is_rollback == 'false'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: './sihat-tcm'
        format: 'sarif'
        output: 'trivy-results.sarif'
        
    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'
        
    - name: Dependency vulnerability check
      working-directory: ./sihat-tcm
      run: |
        pnpm audit --audit-level moderate || echo "âš ï¸ Vulnerabilities found but continuing deployment"
        
    - name: Check for secrets in code
      uses: trufflesecurity/trufflehog@main
      with:
        path: ./sihat-tcm
        base: main
        head: HEAD
        extra_args: --debug --only-verified
        
  # Database Migration Testing
  database-migration:
    name: Database Migration Test
    runs-on: ubuntu-latest
    needs: [pre-deployment, quality-check]
    if: needs.pre-deployment.outputs.should_deploy == 'true' && needs.pre-deployment.outputs.is_rollback == 'false'
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: sihat_tcm_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
          
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        
    - name: Install Supabase CLI
      run: |
        curl -fsSL https://supabase.com/install.sh | sh
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        
    - name: Test database migrations
      working-directory: ./sihat-tcm
      run: |
        # Initialize Supabase project
        supabase init --force
        
        # Start local Supabase (uses Docker)
        supabase start
        
        # Apply migrations
        supabase db reset --linked=false
        
        # Verify schema
        supabase db diff --linked=false
        
        # Test migration rollback capability
        supabase db reset --linked=false
        
        # Stop Supabase
        supabase stop
        
    - name: Validate migration scripts
      working-directory: ./sihat-tcm
      run: |
        # Check for potential issues in migration files
        find supabase/migrations -name "*.sql" -exec echo "Validating {}" \; -exec cat {} \;
        
        # Ensure migrations are idempotent
        echo "âœ… Migration validation completed"

  # Staging Deployment
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [pre-deployment, quality-check, security-scan, database-migration]
    if: |
      always() && 
      needs.pre-deployment.outputs.should_deploy == 'true' && 
      needs.pre-deployment.outputs.target_environment == 'staging' &&
      (needs.quality-check.result == 'success' || needs.quality-check.result == 'skipped') &&
      (needs.security-scan.result == 'success' || needs.security-scan.result == 'skipped') &&
      (needs.database-migration.result == 'success' || needs.database-migration.result == 'skipped')
    
    environment:
      name: staging
      url: https://staging.sihat-tcm.com
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.inputs.rollback_sha || github.sha }}
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        
    - name: Setup pnpm
      uses: pnpm/action-setup@v2
      with:
        version: ${{ env.PNPM_VERSION }}
        
    - name: Download build artifacts
      if: needs.pre-deployment.outputs.is_rollback == 'false'
      uses: actions/download-artifact@v3
      with:
        name: build-artifacts-${{ github.sha }}
        path: sihat-tcm/
        
    - name: Install dependencies and build (for rollback)
      if: needs.pre-deployment.outputs.is_rollback == 'true'
      working-directory: ./sihat-tcm
      run: |
        pnpm install --frozen-lockfile
        pnpm run build
      env:
        NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.STAGING_SUPABASE_URL }}
        NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.STAGING_SUPABASE_ANON_KEY }}
        SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.STAGING_SUPABASE_SERVICE_KEY }}
        GEMINI_API_KEY: ${{ secrets.STAGING_GEMINI_API_KEY }}
        NEXT_PUBLIC_APP_URL: https://staging.sihat-tcm.com
        
    - name: Create deployment backup
      run: |
        echo "Creating deployment backup for staging..."
        curl -X POST "${{ secrets.STAGING_SUPABASE_URL }}/rest/v1/rpc/create_backup" \
          -H "Authorization: Bearer ${{ secrets.STAGING_SUPABASE_SERVICE_KEY }}" \
          -H "Content-Type: application/json" \
          -d '{"backup_name": "pre_deploy_staging_${{ github.sha }}"}' || echo "Backup creation failed, continuing..."
        
    - name: Deploy to Vercel (Staging)
      uses: amondnet/vercel-action@v25
      id: vercel_deploy
      with:
        vercel-token: ${{ secrets.VERCEL_TOKEN }}
        vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
        vercel-project-id: ${{ secrets.VERCEL_STAGING_PROJECT_ID }}
        vercel-args: '--prod --env ENVIRONMENT=staging'
        working-directory: ./sihat-tcm
        
    - name: Wait for deployment to be ready
      run: |
        echo "Waiting for deployment to be ready..."
        sleep 60
        
    - name: Comprehensive health check
      id: health_check
      run: |
        echo "Running comprehensive health checks..."
        
        # Basic health check
        for i in {1..${{ env.HEALTH_CHECK_RETRIES }}}; do
          if curl -f https://staging.sihat-tcm.com/api/monitoring/health; then
            echo "âœ… Health check passed on attempt $i"
            break
          else
            echo "âŒ Health check failed on attempt $i"
            if [ $i -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
              echo "health_check_failed=true" >> $GITHUB_OUTPUT
              exit 1
            fi
            sleep 30
          fi
        done
        
        # Extended smoke tests
        echo "Running smoke tests..."
        
        # Test main page
        curl -f https://staging.sihat-tcm.com/ | grep -q "Sihat TCM" || exit 1
        
        # Test API endpoints
        curl -f https://staging.sihat-tcm.com/api/monitoring/health || exit 1
        curl -f https://staging.sihat-tcm.com/api/monitoring/metrics || exit 1
        
        # Test authentication endpoints
        curl -f https://staging.sihat-tcm.com/api/config/gemini-key \
          -H "Authorization: Bearer ${{ secrets.STAGING_TEST_TOKEN }}" || echo "Auth test skipped"
        
        echo "âœ… All smoke tests passed"
        
    - name: Performance baseline test
      run: |
        echo "Running performance baseline tests..."
        
        # Test page load times
        start_time=$(date +%s%3N)
        curl -s https://staging.sihat-tcm.com/ > /dev/null
        end_time=$(date +%s%3N)
        load_time=$((end_time - start_time))
        
        echo "Page load time: ${load_time}ms"
        
        if [ $load_time -gt 5000 ]; then
          echo "âš ï¸ Page load time exceeds 5 seconds"
        else
          echo "âœ… Page load time acceptable"
        fi
        
        # Test API response times
        start_time=$(date +%s%3N)
        curl -s https://staging.sihat-tcm.com/api/monitoring/health > /dev/null
        end_time=$(date +%s%3N)
        api_time=$((end_time - start_time))
        
        echo "API response time: ${api_time}ms"
        
        if [ $api_time -gt 2000 ]; then
          echo "âš ï¸ API response time exceeds 2 seconds"
        else
          echo "âœ… API response time acceptable"
        fi
        
    - name: Start deployment monitoring
      run: |
        echo "Starting deployment monitoring..."
        
        # Trigger monitoring script
        curl -X POST "${{ secrets.MONITORING_WEBHOOK }}" \
          -H "Content-Type: application/json" \
          -d '{
            "event": "deployment_started",
            "environment": "staging",
            "version": "${{ github.sha }}",
            "rollback": ${{ needs.pre-deployment.outputs.is_rollback }},
            "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"
          }' || echo "Monitoring webhook failed"
        
    - name: Rollback on failure
      if: failure() && steps.health_check.outputs.health_check_failed == 'true'
      run: |
        echo "ðŸš¨ Deployment failed, initiating rollback..."
        
        # Get previous successful deployment
        PREVIOUS_DEPLOYMENT=$(curl -s "https://api.vercel.com/v6/deployments?projectId=${{ secrets.VERCEL_STAGING_PROJECT_ID }}&state=READY&limit=2" \
          -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" | \
          jq -r '.deployments[1].uid // empty')
        
        if [ -n "$PREVIOUS_DEPLOYMENT" ]; then
          echo "Rolling back to deployment: $PREVIOUS_DEPLOYMENT"
          
          # Promote previous deployment
          curl -X PATCH "https://api.vercel.com/v9/projects/${{ secrets.VERCEL_STAGING_PROJECT_ID }}/domains/staging.sihat-tcm.com" \
            -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{"redirect": "'$PREVIOUS_DEPLOYMENT'.vercel.app"}'
            
          echo "âœ… Rollback completed"
        else
          echo "âŒ No previous deployment found for rollback"
        fi
        
    - name: Notify deployment result
      if: always()
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        message: |
          ${{ job.status == 'success' && 'âœ…' || 'âŒ' }} Staging deployment ${{ job.status }}
          
          **Details:**
          â€¢ Environment: Staging
          â€¢ Branch: ${{ github.ref_name }}
          â€¢ Commit: ${{ github.sha }}
          â€¢ Rollback: ${{ needs.pre-deployment.outputs.is_rollback }}
          â€¢ URL: https://staging.sihat-tcm.com
          â€¢ Actor: ${{ github.actor }}
          
          ${{ job.status == 'failure' && '**Action Required:** Check logs and consider rollback' || '' }}

  # Production Deployment
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-deployment, quality-check, security-scan, database-migration]
    if: |
      always() && 
      needs.pre-deployment.outputs.should_deploy == 'true' && 
      needs.pre-deployment.outputs.target_environment == 'production' &&
      (needs.quality-check.result == 'success' || needs.quality-check.result == 'skipped') &&
      (needs.security-scan.result == 'success' || needs.security-scan.result == 'skipped') &&
      (needs.database-migration.result == 'success' || needs.database-migration.result == 'skipped')
    
    environment:
      name: production
      url: https://sihat-tcm.com
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.inputs.rollback_sha || github.sha }}
        
    - name: Production deployment confirmation
      if: needs.pre-deployment.outputs.is_rollback == 'false'
      run: |
        echo "ðŸš€ PRODUCTION DEPLOYMENT INITIATED"
        echo "Commit: ${{ github.sha }}"
        echo "Actor: ${{ github.actor }}"
        echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
        
    - name: Rollback deployment confirmation
      if: needs.pre-deployment.outputs.is_rollback == 'true'
      run: |
        echo "ðŸ”„ PRODUCTION ROLLBACK INITIATED"
        echo "Target commit: ${{ github.event.inputs.rollback_sha }}"
        echo "Actor: ${{ github.actor }}"
        echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        
    - name: Setup pnpm
      uses: pnpm/action-setup@v2
      with:
        version: ${{ env.PNPM_VERSION }}
        
    - name: Download build artifacts
      if: needs.pre-deployment.outputs.is_rollback == 'false'
      uses: actions/download-artifact@v3
      with:
        name: build-artifacts-${{ github.sha }}
        path: sihat-tcm/
        
    - name: Install dependencies and build (for rollback)
      if: needs.pre-deployment.outputs.is_rollback == 'true'
      working-directory: ./sihat-tcm
      run: |
        pnpm install --frozen-lockfile
        pnpm run build
      env:
        NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.PROD_SUPABASE_URL }}
        NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.PROD_SUPABASE_ANON_KEY }}
        SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.PROD_SUPABASE_SERVICE_KEY }}
        GEMINI_API_KEY: ${{ secrets.PROD_GEMINI_API_KEY }}
        NEXT_PUBLIC_APP_URL: https://sihat-tcm.com
        
    - name: Create production backup
      run: |
        echo "Creating production backup..."
        
        # Database backup
        curl -X POST "${{ secrets.PROD_SUPABASE_URL }}/rest/v1/rpc/create_backup" \
          -H "Authorization: Bearer ${{ secrets.PROD_SUPABASE_SERVICE_KEY }}" \
          -H "Content-Type: application/json" \
          -d '{"backup_name": "pre_deploy_prod_${{ github.sha }}_$(date +%Y%m%d_%H%M%S)"}' || {
            echo "âŒ Database backup failed"
            exit 1
          }
        
        # Store current deployment info for rollback
        CURRENT_DEPLOYMENT=$(curl -s "https://api.vercel.com/v6/deployments?projectId=${{ secrets.VERCEL_PROD_PROJECT_ID }}&state=READY&limit=1" \
          -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" | \
          jq -r '.deployments[0].uid // empty')
        
        echo "PREVIOUS_DEPLOYMENT=$CURRENT_DEPLOYMENT" >> $GITHUB_ENV
        echo "âœ… Backup completed. Previous deployment: $CURRENT_DEPLOYMENT"
        
    - name: Enable maintenance mode
      if: needs.pre-deployment.outputs.is_rollback == 'false'
      run: |
        echo "Enabling maintenance mode..."
        
        # Set maintenance mode flag
        curl -X POST "${{ secrets.PROD_SUPABASE_URL }}/rest/v1/admin_settings" \
          -H "Authorization: Bearer ${{ secrets.PROD_SUPABASE_SERVICE_KEY }}" \
          -H "Content-Type: application/json" \
          -d '{"key": "maintenance_mode", "value": "true", "updated_at": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}' || echo "Maintenance mode setting failed"
        
    - name: Deploy to Vercel (Production)
      uses: amondnet/vercel-action@v25
      id: vercel_deploy
      with:
        vercel-token: ${{ secrets.VERCEL_TOKEN }}
        vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
        vercel-project-id: ${{ secrets.VERCEL_PROD_PROJECT_ID }}
        vercel-args: '--prod --env ENVIRONMENT=production'
        working-directory: ./sihat-tcm
        
    - name: Wait for deployment propagation
      run: |
        echo "Waiting for deployment to propagate globally..."
        sleep 120  # Wait longer for production
        
    - name: Comprehensive production health check
      id: health_check
      run: |
        echo "Running comprehensive production health checks..."
        
        # Extended health check with retries
        for i in {1..${{ env.HEALTH_CHECK_RETRIES }}}; do
          echo "Health check attempt $i/${{ env.HEALTH_CHECK_RETRIES }}..."
          
          if curl -f --max-time 30 https://sihat-tcm.com/api/monitoring/health; then
            echo "âœ… Basic health check passed on attempt $i"
            break
          else
            echo "âŒ Health check failed on attempt $i"
            if [ $i -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
              echo "health_check_failed=true" >> $GITHUB_OUTPUT
              exit 1
            fi
            sleep 60
          fi
        done
        
        # Comprehensive system validation
        echo "Running comprehensive system validation..."
        
        # Test main page
        curl -f --max-time 30 https://sihat-tcm.com/ | grep -q "Sihat TCM" || {
          echo "âŒ Main page validation failed"
          exit 1
        }
        
        # Test critical API endpoints
        curl -f --max-time 30 https://sihat-tcm.com/api/monitoring/health || {
          echo "âŒ Health endpoint failed"
          exit 1
        }
        
        curl -f --max-time 30 https://sihat-tcm.com/api/monitoring/metrics || {
          echo "âŒ Metrics endpoint failed"
          exit 1
        }
        
        # Test database connectivity through health endpoint
        HEALTH_RESPONSE=$(curl -s https://sihat-tcm.com/api/monitoring/health)
        DB_STATUS=$(echo "$HEALTH_RESPONSE" | jq -r '.components.database.status // "unknown"')
        
        if [ "$DB_STATUS" != "healthy" ]; then
          echo "âŒ Database health check failed: $DB_STATUS"
          exit 1
        fi
        
        # Test AI service connectivity
        AI_STATUS=$(echo "$HEALTH_RESPONSE" | jq -r '.components.ai_service.status // "unknown"')
        
        if [ "$AI_STATUS" != "healthy" ] && [ "$AI_STATUS" != "degraded" ]; then
          echo "âŒ AI service health check failed: $AI_STATUS"
          exit 1
        fi
        
        echo "âœ… All comprehensive health checks passed"
        
    - name: Performance and load testing
      run: |
        echo "Running performance and load tests..."
        
        # Test response times under load
        for endpoint in "/" "/api/monitoring/health" "/api/monitoring/metrics"; do
          echo "Testing endpoint: $endpoint"
          
          total_time=0
          success_count=0
          
          for i in {1..10}; do
            start_time=$(date +%s%3N)
            
            if curl -f --max-time 10 "https://sihat-tcm.com$endpoint" > /dev/null 2>&1; then
              end_time=$(date +%s%3N)
              response_time=$((end_time - start_time))
              total_time=$((total_time + response_time))
              success_count=$((success_count + 1))
              echo "  Request $i: ${response_time}ms âœ…"
            else
              echo "  Request $i: FAILED âŒ"
            fi
            
            sleep 1
          done
          
          if [ $success_count -gt 0 ]; then
            avg_time=$((total_time / success_count))
            success_rate=$((success_count * 10))
            echo "  Average response time: ${avg_time}ms"
            echo "  Success rate: ${success_rate}%"
            
            if [ $avg_time -gt 5000 ]; then
              echo "  âš ï¸ Average response time exceeds 5 seconds"
            fi
            
            if [ $success_rate -lt 90 ]; then
              echo "  âŒ Success rate below 90%"
              exit 1
            fi
          else
            echo "  âŒ All requests failed for $endpoint"
            exit 1
          fi
        done
        
        echo "âœ… Performance tests completed successfully"
        
    - name: Disable maintenance mode
      if: success()
      run: |
        echo "Disabling maintenance mode..."
        
        curl -X POST "${{ secrets.PROD_SUPABASE_URL }}/rest/v1/admin_settings" \
          -H "Authorization: Bearer ${{ secrets.PROD_SUPABASE_SERVICE_KEY }}" \
          -H "Content-Type: application/json" \
          -d '{"key": "maintenance_mode", "value": "false", "updated_at": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}' || echo "Maintenance mode disable failed"
        
        echo "âœ… Maintenance mode disabled"
        
    - name: Start production monitoring
      if: success()
      run: |
        echo "Starting enhanced production monitoring..."
        
        # Trigger monitoring systems
        curl -X POST "${{ secrets.MONITORING_WEBHOOK }}" \
          -H "Content-Type: application/json" \
          -d '{
            "event": "production_deployment_success",
            "environment": "production",
            "version": "${{ github.sha }}",
            "rollback": ${{ needs.pre-deployment.outputs.is_rollback }},
            "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
            "deployment_url": "https://sihat-tcm.com"
          }' || echo "Monitoring webhook failed"
        
        # Start continuous monitoring script
        nohup bash ./sihat-tcm/scripts/monitor-deployment.sh production > monitoring.log 2>&1 &
        echo "âœ… Production monitoring started"
        
    - name: Rollback on failure
      if: failure() && steps.health_check.outputs.health_check_failed == 'true'
      run: |
        echo "ðŸš¨ PRODUCTION DEPLOYMENT FAILED - INITIATING EMERGENCY ROLLBACK"
        
        if [ -n "$PREVIOUS_DEPLOYMENT" ]; then
          echo "Rolling back to previous deployment: $PREVIOUS_DEPLOYMENT"
          
          # Immediate rollback to previous deployment
          curl -X PATCH "https://api.vercel.com/v9/projects/${{ secrets.VERCEL_PROD_PROJECT_ID }}/domains/sihat-tcm.com" \
            -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{"redirect": "'$PREVIOUS_DEPLOYMENT'.vercel.app"}' || {
              echo "âŒ Automatic rollback failed"
              exit 1
            }
          
          # Wait for rollback to propagate
          sleep 60
          
          # Verify rollback
          if curl -f https://sihat-tcm.com/api/monitoring/health; then
            echo "âœ… Rollback successful - service restored"
          else
            echo "âŒ Rollback verification failed - manual intervention required"
            exit 1
          fi
          
          # Disable maintenance mode after rollback
          curl -X POST "${{ secrets.PROD_SUPABASE_URL }}/rest/v1/admin_settings" \
            -H "Authorization: Bearer ${{ secrets.PROD_SUPABASE_SERVICE_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{"key": "maintenance_mode", "value": "false", "updated_at": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}' || echo "Maintenance mode disable failed"
          
        else
          echo "âŒ No previous deployment found - manual intervention required"
          exit 1
        fi
        
    - name: Send critical alerts on failure
      if: failure()
      run: |
        echo "Sending critical failure alerts..."
        
        # Send to multiple channels for critical production failures
        curl -X POST "${{ secrets.SLACK_WEBHOOK }}" \
          -H "Content-Type: application/json" \
          -d '{
            "text": "ðŸš¨ CRITICAL: Production deployment failed",
            "channel": "#production-alerts",
            "attachments": [{
              "color": "danger",
              "fields": [
                {"title": "Environment", "value": "Production", "short": true},
                {"title": "Status", "value": "FAILED", "short": true},
                {"title": "Commit", "value": "${{ github.sha }}", "short": true},
                {"title": "Actor", "value": "${{ github.actor }}", "short": true},
                {"title": "Rollback", "value": "${{ needs.pre-deployment.outputs.is_rollback }}", "short": true},
                {"title": "Action Required", "value": "Immediate investigation required", "short": false}
              ]
            }]
          }' || echo "Slack alert failed"
        
        # Send email alert
        if [ -n "${{ secrets.ALERT_EMAIL }}" ]; then
          curl -X POST "/api/monitoring/alert" \
            -H "Content-Type: application/json" \
            -d '{
              "type": "critical_deployment_failure",
              "environment": "production",
              "commit": "${{ github.sha }}",
              "actor": "${{ github.actor }}",
              "recipients": ["${{ secrets.ALERT_EMAIL }}"]
            }' || echo "Email alert failed"
        fi
        
    - name: Notify deployment result
      if: always()
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: ${{ job.status == 'success' && '#production' || '#production-alerts' }}
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        message: |
          ${{ job.status == 'success' && 'ðŸš€âœ…' || 'ðŸš¨âŒ' }} Production deployment ${{ job.status }}
          
          **Details:**
          â€¢ Environment: Production
          â€¢ Branch: ${{ github.ref_name }}
          â€¢ Commit: ${{ github.sha }}
          â€¢ Rollback: ${{ needs.pre-deployment.outputs.is_rollback }}
          â€¢ URL: https://sihat-tcm.com
          â€¢ Actor: ${{ github.actor }}
          â€¢ Timestamp: ${{ github.event.head_commit.timestamp }}
          
          ${{ job.status == 'success' && '**Status:** All systems operational' || '**Status:** CRITICAL - Immediate attention required' }}
          ${{ job.status == 'failure' && '**Action Required:** Check logs, verify rollback, escalate if needed' || '' }}
          
  # Post-deployment monitoring
  post-deployment-monitoring:
    name: Post-deployment Monitoring
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Determine monitoring environment
      id: env_check
      run: |
        if [ "${{ needs.deploy-production.result }}" = "success" ]; then
          echo "environment=production" >> $GITHUB_OUTPUT
          echo "url=https://sihat-tcm.com" >> $GITHUB_OUTPUT
        elif [ "${{ needs.deploy-staging.result }}" = "success" ]; then
          echo "environment=staging" >> $GITHUB_OUTPUT
          echo "url=https://staging.sihat-tcm.com" >> $GITHUB_OUTPUT
        fi
        
    - name: Extended monitoring setup
      run: |
        echo "Setting up extended monitoring for ${{ steps.env_check.outputs.environment }}..."
        
        # Start monitoring script
        chmod +x ./sihat-tcm/scripts/monitor-deployment.sh
        ./sihat-tcm/scripts/monitor-deployment.sh ${{ steps.env_check.outputs.environment }} &
        MONITOR_PID=$!
        
        # Monitor for 10 minutes
        sleep 600
        
        # Stop monitoring
        kill $MONITOR_PID || true
        
        echo "âœ… Extended monitoring completed"
        
    - name: Generate deployment report
      run: |
        echo "Generating deployment report..."
        
        # Create comprehensive deployment report
        cat > deployment_report.md << EOF
        # Deployment Report
        
        **Environment:** ${{ steps.env_check.outputs.environment }}
        **URL:** ${{ steps.env_check.outputs.url }}
        **Commit:** ${{ github.sha }}
        **Branch:** ${{ github.ref_name }}
        **Actor:** ${{ github.actor }}
        **Timestamp:** $(date -u +%Y-%m-%dT%H:%M:%SZ)
        
        ## Health Check Results
        
        \`\`\`
        $(curl -s ${{ steps.env_check.outputs.url }}/api/monitoring/health | jq '.')
        \`\`\`
        
        ## Performance Metrics
        
        - Page Load Time: $(curl -w "%{time_total}s" -s ${{ steps.env_check.outputs.url }} -o /dev/null)
        - API Response Time: $(curl -w "%{time_total}s" -s ${{ steps.env_check.outputs.url }}/api/monitoring/health -o /dev/null)
        
        ## Next Steps
        
        - [ ] Monitor error rates for next 24 hours
        - [ ] Verify all user flows are working
        - [ ] Check performance metrics
        - [ ] Review logs for any issues
        
        EOF
        
        echo "âœ… Deployment report generated"
        
    - name: Upload deployment report
      uses: actions/upload-artifact@v3
      with:
        name: deployment-report-${{ steps.env_check.outputs.environment }}-${{ github.sha }}
        path: deployment_report.md
        retention-days: 30

  # Mobile App Build (Conditional)
  build-mobile:
    name: Build Mobile App
    runs-on: ubuntu-latest
    needs: [pre-deployment, quality-check]
    if: |
      needs.pre-deployment.outputs.should_deploy == 'true' && 
      needs.pre-deployment.outputs.target_environment == 'production' &&
      needs.pre-deployment.outputs.is_rollback == 'false'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        
    - name: Setup Expo CLI
      run: npm install -g @expo/cli eas-cli
      
    - name: Install mobile dependencies
      working-directory: ./sihat-tcm-mobile
      run: npm install
      
    - name: Configure EAS
      working-directory: ./sihat-tcm-mobile
      run: |
        # Login to Expo
        echo "${{ secrets.EXPO_TOKEN }}" | expo login --non-interactive
        
        # Configure EAS build
        eas build:configure --non-interactive
        
    - name: Build Android APK
      working-directory: ./sihat-tcm-mobile
      run: |
        echo "Building Android APK..."
        eas build --platform android --profile production --non-interactive --wait
        
    - name: Build iOS (if certificates available)
      working-directory: ./sihat-tcm-mobile
      if: secrets.IOS_CERTIFICATES_AVAILABLE == 'true'
      run: |
        echo "Building iOS app..."
        eas build --platform ios --profile production --non-interactive --wait
        
    - name: Upload mobile artifacts
      uses: actions/upload-artifact@v3
      with:
        name: mobile-builds-${{ github.sha }}
        path: |
          sihat-tcm-mobile/dist/
          sihat-tcm-mobile/build/
        retention-days: 30
        
    - name: Notify mobile build completion
      uses: 8398a7/action-slack@v3
      if: always()
      with:
        status: ${{ job.status }}
        channel: '#mobile-builds'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        message: |
          ðŸ“± Mobile app build ${{ job.status }}
          
          **Details:**
          â€¢ Platform: Android ${{ secrets.IOS_CERTIFICATES_AVAILABLE == 'true' && '+ iOS' || '' }}
          â€¢ Commit: ${{ github.sha }}
          â€¢ Branch: ${{ github.ref_name }}
          
          ${{ job.status == 'success' && 'Ready for distribution' || 'Build failed - check logs' }}

  # Rollback Job (Manual trigger only)
  manual-rollback:
    name: Manual Rollback
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.rollback_sha != ''
    
    steps:
    - name: Checkout rollback target
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.inputs.rollback_sha }}
        
    - name: Validate rollback target
      run: |
        echo "Validating rollback target: ${{ github.event.inputs.rollback_sha }}"
        
        # Ensure we're not rolling back to the same commit
        if [ "${{ github.event.inputs.rollback_sha }}" = "${{ github.sha }}" ]; then
          echo "âŒ Cannot rollback to the same commit"
          exit 1
        fi
        
        # Validate commit exists and is not too old
        COMMIT_DATE=$(git show -s --format=%ct ${{ github.event.inputs.rollback_sha }})
        CURRENT_DATE=$(date +%s)
        DAYS_OLD=$(( (CURRENT_DATE - COMMIT_DATE) / 86400 ))
        
        if [ $DAYS_OLD -gt 30 ]; then
          echo "âš ï¸ Warning: Rolling back to a commit that is $DAYS_OLD days old"
          echo "This may cause compatibility issues"
        fi
        
        echo "âœ… Rollback target validation passed"
        
    - name: Execute rollback script
      run: |
        echo "Executing rollback to ${{ github.event.inputs.rollback_sha }}..."
        
        chmod +x ./sihat-tcm/scripts/rollback.sh
        ./sihat-tcm/scripts/rollback.sh ${{ github.event.inputs.environment }} ${{ github.event.inputs.rollback_sha }}
        
    - name: Verify rollback
      run: |
        echo "Verifying rollback..."
        
        if [ "${{ github.event.inputs.environment }}" = "production" ]; then
          URL="https://sihat-tcm.com"
        else
          URL="https://staging.sihat-tcm.com"
        fi
        
        # Wait for rollback to propagate
        sleep 120
        
        # Verify service is healthy
        for i in {1..10}; do
          if curl -f "$URL/api/monitoring/health"; then
            echo "âœ… Rollback verification passed on attempt $i"
            break
          else
            echo "âŒ Rollback verification failed on attempt $i"
            if [ $i -eq 10 ]; then
              exit 1
            fi
            sleep 30
          fi
        done
        
    - name: Notify rollback completion
      uses: 8398a7/action-slack@v3
      if: always()
      with:
        status: ${{ job.status }}
        channel: '#production-alerts'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        message: |
          ðŸ”„ Manual rollback ${{ job.status }}
          
          **Details:**
          â€¢ Environment: ${{ github.event.inputs.environment }}
          â€¢ Target Commit: ${{ github.event.inputs.rollback_sha }}
          â€¢ Initiated by: ${{ github.actor }}
          â€¢ Status: ${{ job.status }}
          
          ${{ job.status == 'success' && 'âœ… Service restored successfully' || 'âŒ Rollback failed - immediate intervention required' }}